#!/usr/bin/env python3

import collections
import csv
import datetime
import json
import os.path
import re
import sys


def sitems(d):
    return sorted(d.items(), key = lambda x: x[0])


class Jiffy(object):
    """
    This class represents data imported from Jiffy.
    """

    def __init__(self):
        self._worked = collections.defaultdict( # Customer
            lambda: collections.defaultdict( # Week
                lambda: collections.defaultdict( # Day
                    lambda: [] # Tasks on the day
                )
            )
        )

    def load(self, fn):
        """
        Load an export generated by Jiffy.
        """
        with open(fn, 'r') as csvfile:
            # Read the CSV, using the first row as the header
            reader = csv.DictReader(csvfile, delimiter=',')
            for row in reader:
                # Parse the data from the row
                customer, relation = ([s.strip() for s in row['Customer'].split('/', 1)] + [''])[:2]
                project = row['Project'].strip()
                task = re.sub('\s+\d+$', '', row['Task']).strip()
                start = datetime.datetime.strptime(row['Start time'], '%Y-%m-%d %H:%M:%S')
                end = datetime.datetime.strptime(row['Stop time'], '%Y-%m-%d %H:%M:%S')
                _, week, day = start.isocalendar()
                minutes = int(row['Minutes'])
                note = row['Note'].strip()

                # Store the parsed data
                self._worked[customer][week][day].append({
                    'start': start,
                    'end': end,
                    'relation': relation,
                    'project': project,
                    'task': task,
                    'note': note,
                    'minutes': minutes
                })

                # Sort the list
                self._worked[customer][week][day].sort(key = lambda x: x['start'])

    def get_weeks(self, customer):
        """
        Get a list of all weeks.
        """
        return sorted(set(self._worked[customer].keys()))

    def get_customers(self):
        """
        Get a list of all customers.
        """
        return self._worked.keys()

    @staticmethod
    def _with_title(func, customer):
        """
        Execute a generate_ function for a specific customer, with an added line
        specifying which customer the data is for.

        This is used when the methods are called without specifying the customer.
        """
        return "Work for {} in this period:\n\n".format(customer) + func(customer)

    def generate_overview(self, customer=None):
        """
        Generate an overview of the worked hours per day/weeknumber per customer.

        Useful for quickly determining the worked hours without needing detailed
        information about what was done.

        If a customer name is given, only generate for that customer. Else,
        generate the data for all customers.
        """
        # Listing of all customers
        if not customer:
            return "\r\n\r\n".join([self._with_title(self.generate_overview, c) for c in self.get_customers()])

        # Generate simple log, hours only.
        output = ''
        customer_work = self._worked[customer]
        itemses = []
        itemses.append(['Week', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'])
        for week, work in sitems(customer_work):
            items = [week]
            for day in range(1, 8):
                minutes = sum([t['minutes'] for t in work[day]])
                if minutes > 0:
                    items.append(int(minutes / 3) / 20.0)
                else:
                    items.append('')
            itemses.append(items)
        for items in itemses:
            output += ' '.join(["{0:<6}".format(item) for item in items]) + "\r\n"
        return output

    def generate_projectlog(self, week=None, customer=None):
        """
        Generate a view of the worked hours per project per customer per week.

        This is based/grouped around what was done, instead of when it was done.

        If a customer name is given, only generate for that customer. Else,
        generate the data for all customers.
        """
        # Listing of all customers
        if not week:
            return "\r\n\r\n".join([self._with_title(self.generate_projectlog, w, customer) for w in self.get_weeks()])
        if not customer:
            return "\r\n\r\n".join([self._with_title(self.generate_projectlog, week, c) for c in self.get_customers()])

        # Determine the worked hours per task.
        worked = collections.defaultdict( # Relation
            lambda: collections.defaultdict( # Project
                lambda: collections.defaultdict( # Task
                    lambda: collections.defaultdict( # Day
                        lambda: 0 # Minutes
                    )
                )
            )
        )
        work = self._worked[customer][week]
        for day in range(1, 8):
            for task in work[day]:
                worked[task['relation']][task['project']][task['task']][day] += task['minutes']

        # Generate project log
        itemses = []
        itemses.append(['What', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Total'])
        for relation, rwork in sitems(worked):
            itemses.append(['----------'])
            indent = ''
            if relation:
                itemses.append([relation])
                indent = ' '
            for project, pwork in sitems(rwork):
                itemses.append([indent + project])
                for task, twork in sitems(pwork):
                    items = [indent + ' ' + task]
                    for day in range(1, 8):
                        items.append(twork[day])
                    items.append(sum(items[1:]))
                    itemses.append(items)

        # Calculate the totals.
        itemses.append(['----------'])
        itemses.append(['Total', 0, 0, 0, 0, 0, 0, 0, 0])
        for i in range(1, 8):
            itemses[-1][i] = sum([item[i] for item in itemses[1:-1] if i < len(item)])
        itemses[-1][-1] = sum(itemses[-1][1:-1])

        # Format the times.
        for items in itemses:
            for i, item in enumerate(items):
                if isinstance(item, int):
                    if item > 0:
                        item = "{:02}:{:02}".format(int(item / 60), item % 60)
                    else:
                        item = ''
                    items[i] = item

        # Calculate the max length of each column.
        lengths = [0] * len(itemses[0])
        for items in itemses:
            for i, item in enumerate(items):
                lengths[i] = max(lengths[i], len(str(item)) + 2)

        # Output.
        output = ''
        for items in itemses:
            for i, item in enumerate(items):
                output += "{1:<{0}} ".format(lengths[i], item)
            output += "\r\n"
        return output

    def generate_details(self, customer=None):
        """
        Generate a detailed view of the worked hours per customer.

        This includes the details about when and what was done exactly, which
        makes it more verbose.

        If a customer name is given, only generate for that customer. Else,
        generate the data for all customers.
        """
        # Listing of all customers
        if not customer:
            return "\r\n\r\n".join([self._with_title(self.generate_details, c) for c in self.get_customers()])

        # Generate detailed log
        output = ''
        customer_work = self._worked[customer]
        itemses = []
        itemses.append(['Date', 'Start', 'End', 'Duration', 'Relation', 'Project', 'Task', 'Note'])
        for week, work in sitems(customer_work):
            for day in range(1, 8):
                for task in work[day]:
                    itemses.append([
                        task['start'].strftime("%a %d %b"),
                        task['start'].strftime("%H:%M"),
                        task['end'].strftime("%H:%M"),
                        "{:02}:{:02}".format(int(task['minutes'] / 60), task['minutes'] % 60),
                        task['relation'],
                        task['project'],
                        task['task'],
                        task['note'],
                    ])
        lengths = [0] * len(itemses[0])
        for items in itemses:
            for i, item in enumerate(items):
                lengths[i] = max(lengths[i], len(str(item)) + 2)
        lengths[-1] = 0
        for items in itemses:
            for i, item in enumerate(items):
                output += "{1:<{0}} ".format(lengths[i], item)
            output += "\r\n"
        return output

    def generate_export(self, customer=None):
        """
        Generate an export of the data, in simple data types.

        The way the data is presented will differ a bit from how it is stored
        internally, to make more sense for general cases.

        This is fit for direct serialisation to, for example, JSON.
        """
        # Listing of all customers
        if not customer:
            return dict([(c, self.generate_export(c)) for c in self.get_customers()])

        # Generate the export data
        customer_work = self._worked[customer]
        for week_work in customer_work.values():
            for day_work in week_work.values():
                for task in day_work:
                    yield {
                        'start': task['start'].timestamp(),
                        'end': task['end'].timestamp(),
                        'relation': task['relation'],
                        'project': task['project'],
                        'task': task['task'],
                        'note': task['note'],
                    }


if __name__ == '__main__':
    # Read the jiffy files specified as arguments, and generate detailed,
    # per-customer log of these
    for infile in sys.argv[1:]:
        if not infile.endswith('jiffy.csv'):
            print("Ignoring file {} as it is not a jiffy.csv file.".format(infile))
            continue

        # Read the input file
        jiffy = Jiffy()
        jiffy.load(infile)

        # Generate a generic overview
        with open(infile + '.overview.log', 'w') as f:
            f.write(jiffy.generate_overview())

        # Generate a more detailed view per customer
        for customer in jiffy.get_customers():
            with open(infile + '.{}.log'.format(customer), 'w') as f:
                worked = sum([t['end'] - t['start'] for t in jiffy.generate_export(customer)]) / 3600
                f.write("Total hours worked this time period: {:02.2f}\r\n".format(worked))
                f.write('\r\n')
                f.write("=== Overview ===\r\n")
                f.write(jiffy.generate_overview(customer).strip() + '\r\n')
                f.write('\r\n')
                f.write("=== Project log ===\r\n")
                for week in jiffy.get_weeks(customer):
                    f.write("== Week {} ==\r\n".format(week))
                    f.write(jiffy.generate_projectlog(week, customer).strip() + '\r\n')
                f.write("\r\n")
                f.write("=== Details ===\r\n")
                f.write(jiffy.generate_details(customer).strip())

        # Generate files with the raw data for each customer
        for customer in jiffy.get_customers():
            with open(infile + '.{}.json'.format(customer), 'w') as f:
                f.write(json.dumps(list(jiffy.generate_export(customer))))
            with open(infile + '.{}.csv'.format(customer), 'w') as f:
                f.write("starts_at;ends_at;relation;order;sub_order;description\r\n")
                for line in jiffy.generate_export(customer):
                    f.write("{start};{end};{relation};{project};{task};{note}\r\n".format(
                        start=datetime.datetime.fromtimestamp(line['start']).isoformat(),
                        end=datetime.datetime.fromtimestamp(line['end']).isoformat(),
                        relation=line['relation'],
                        project=line['project'],
                        task=line['task'],
                        note=line['note'],
                    ))

        # Remove the input file.
        os.remove(infile)
